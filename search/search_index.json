{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What does this","text":"<p>Linked Services was made by 4geeks.com to manage communication between multiple services and microservices, it manages specifically communications between pairwise services, so, if only two services share the same key, a request just could has two emisors, the other service and itself. It was designed to replace the signature algorithms because them are significally slower.</p>"},{"location":"extending-scope/rest-frameworks/","title":"Rest frameworks","text":"<p>To implement <code>scope</code> and <code>ascope</code> you must use <code>get_decorators</code> and <code>get_handlers</code> functions to get both decorators.</p>"},{"location":"extending-scope/rest-frameworks/#get_app_keys","title":"get_app_keys","text":""},{"location":"extending-scope/rest-frameworks/#arguments","title":"arguments","text":"<ul> <li><code>app_slug</code>: - slug or your application.</li> </ul>"},{"location":"extending-scope/rest-frameworks/#returns","title":"Returns","text":"<p>It returns a tuple of (info, key, legacy_key or None) where:</p> <ul> <li>info: (app_id, algorithm, strategy, schema, require_an_agreement, required_scopes, optional_scopes, webhook_url, redirect_url, app_url)</li> <li>key and legacy_key: (public_key, private_key)</li> </ul>"},{"location":"extending-scope/rest-frameworks/#info","title":"info","text":"<ul> <li><code>app_id</code>: application id.</li> <li><code>algorithm</code>: algorithm of the keys used.</li> <li><code>strategy</code>: authentication strategy used by default.</li> <li><code>schema</code>: schema of the keys used.</li> <li><code>require_an_agreement</code>: if true, the user must accept share its data with the other application.</li> <li><code>required_scopes</code>: list of strings with all scopes that are required.</li> <li><code>optional_scopes</code> list of strings with all scopes that are optional.</li> <li><code>webhook_url</code>: webhook url.</li> <li><code>redirect_url</code>: redirect url.</li> <li><code>app_url</code>: application url.</li> </ul>"},{"location":"extending-scope/rest-frameworks/#key-and-legacy_key","title":"key and legacy_key","text":"<ul> <li><code>public_key</code>: public key string</li> <li><code>private_key</code>: private key string or None</li> </ul>"},{"location":"extending-scope/rest-frameworks/#get_user_scopes","title":"get_user_scopes","text":""},{"location":"extending-scope/rest-frameworks/#arguments_1","title":"arguments","text":"<ul> <li><code>app_slug</code>: slug or your application.</li> <li><code>user_id</code>: optional user id.</li> </ul>"},{"location":"extending-scope/rest-frameworks/#returns_1","title":"Returns","text":"<p>Two tuple of strings, the second tuple should be None. It returns the required scopes as first tuple and the optional as second tuple.</p>"},{"location":"extending-scope/rest-frameworks/#example","title":"Example","text":"<pre><code>from linked_services.core.decorators import get_decorators, get_handlers\nfrom linked_services.django.actions import get_app_keys, get_user_scopes\n\n__all__ = [\"scope\", \"ascope\"]\n\n\nlink_schema, signature_schema = get_handlers(get_app_keys, get_user_scopes)\nscope, ascope = get_decorators(link_schema, signature_schema)\n</code></pre>"},{"location":"extending-service/http-clients/","title":"HTTP clients","text":"<p>You could write a new implementation for a HTTP client here <code>src/linked_services/core/service.py</code>.</p>"},{"location":"extending-service/http-clients/#http-client-preference","title":"HTTP client preference","text":""},{"location":"extending-service/http-clients/#async","title":"Async","text":"<ol> <li><code>aiohttp</code>.</li> <li><code>httpx</code>.</li> <li><code>requests</code>.</li> </ol>"},{"location":"extending-service/http-clients/#sync","title":"Sync","text":"<ol> <li><code>httpx</code>.</li> <li><code>requests</code>.</li> </ol>"},{"location":"extending-service/http-clients/#which-are-supported-right-now","title":"Which are supported right now","text":"<ul> <li><code>aiohttp</code>.</li> <li><code>requests</code>.</li> </ul>"},{"location":"extending-service/http-clients/#syncservice-methods","title":"<code>SyncService</code> methods","text":"<ul> <li><code>__enter__</code>: called when it gets entered into an sync context.</li> <li><code>__exit__</code>: called when it gets exited from an sync context.</li> <li><code>_sync_proxy</code>: called when it requires that the response be a REST framework response.</li> <li><code>_sync_get</code>: called when it tries to do a get request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_options</code>: called when it tries to do a options request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_head</code>: called when it tries to do a head request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_post</code>: called when it tries to do a post request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_webhook</code>: called when it tries to trigger an webhook, it returns a HTTP response or a Rest response.</li> <li><code>_sync_put</code>: called when it tries to do a put request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_patch</code>: called when it tries to do a patch request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_delete</code>: called when it tries to do a delete request, it returns a HTTP response or a Rest response.</li> <li><code>_sync_request</code>: called when it tries to do a generic request, it returns a HTTP response or a Rest response.</li> </ul>"},{"location":"extending-service/http-clients/#asyncservice-methods","title":"<code>AsyncService</code> methods","text":"<ul> <li><code>__aenter__</code>: called when it gets entered into an async context.</li> <li><code>__aexit__</code>: called when it gets exited from an async context.</li> <li><code>_async_proxy</code>: called when it requires that the response be a REST framework response.</li> <li><code>_async_get</code>: called when it tries to do a get request, it returns a HTTP response or a Rest response.</li> <li><code>_async_options</code>: called when it tries to do a options request, it returns a HTTP response or a Rest response.</li> <li><code>_async_head</code>: called when it tries to do a head request, it returns a HTTP response or a Rest response.</li> <li><code>_async_post</code>: called when it tries to do a post request, it returns a HTTP response or a Rest response.</li> <li><code>_async_webhook</code>: called when it tries to trigger an webhook, it returns a HTTP response or a Rest response.</li> <li><code>_async_put</code>: called when it tries to do a put request, it returns a HTTP response or a Rest response.</li> <li><code>_async_patch</code>: called when it tries to do a patch request, it returns a HTTP response or a Rest response.</li> <li><code>_async_delete</code>: called when it tries to do a delete request, it returns a HTTP response or a Rest response.</li> <li><code>_async_request</code>: called when it tries to do a generic request, it returns a HTTP response or a Rest response.</li> </ul>"},{"location":"extending-service/http-clients/#how-to-implement-a-new-http-client","title":"How to implement a new HTTP client","text":"<p>You must implement an <code>SyncService</code> and <code>AsyncService</code> for your new library.</p>"},{"location":"extending-service/http-clients/#detecting-your-new-client","title":"Detecting your new client","text":"<p>First, you need to add an import test here, it will tell to the rest of the code which clients are available.</p> <pre><code>LIBRARIES = {\n    \"requests\": False,\n    \"aiohttp\": False,  # no implemented yet\n    \"httpx\": False,\n}\n\ntry:\n    import requests\n\n    LIBRARIES[\"requests\"] = True\n\nexcept ImportError:\n    pass\n\ntry:\n    from aiohttp.client_reqrep import ClientResponse\n\n    LIBRARIES[\"aiohttp\"] = True\n\nexcept ImportError:\n    pass\n\ntry:\n    import httpx  # noqa: F401\n\n    LIBRARIES[\"httpx\"] = True\n\nexcept ImportError:\n    pass\n</code></pre>"},{"location":"extending-service/http-clients/#implementing-syncservice-and-asyncservice","title":"Implementing <code>SyncService</code> and <code>AsyncService</code>","text":"<p>You must use <code>elif LIBRARIES[\"your-client\"]:</code> to check if your library is available, also, you must remind each client has a different relevance, so, sort them by relevance.</p>"},{"location":"extending-service/http-clients/#syncservice-example","title":"<code>SyncService</code> example","text":"<p>Implementing <code>requests</code> library.</p> <pre><code>if LIBRARIES[\"requests\"]:\n\n    class SyncService:\n\n        def __enter__(self) -&gt; \"Service\":\n\n            self.sync = True\n\n            if isinstance(self.app_pk, self._get_app_cls()):\n                self.app = self.app_pk\n                return self\n\n            try:\n                self.app = self._get_app(self.app_pk)\n\n            except Exception:\n                raise AppNotFound(f\"App {self.app_pk} not found\")\n\n            return self\n\n        def __exit__(\n            self,\n            exc_type: Optional[Type[BaseException]],\n            exc_val: Optional[BaseException],\n            exc_tb: Optional[TracebackType],\n        ) -&gt; None:\n            pass\n\n        def _sync_proxy(self, request: Callable[[], requests.Response], stream: bool) -&gt; StreamingHttpResponse:\n            try:\n                response = request()\n\n            except Exception as e:\n                raise ValidationException(\"Unexpected error: \" + str(e), code=500, slug=\"unexpected-error\")\n\n            header_keys = [x for x in response.headers.keys() if x not in self.banned_keys]\n\n            if stream:\n                resource = StreamingHttpResponse(\n                    response.raw,\n                    status=response.status_code,\n                    reason=response.reason,\n                )\n\n                for header in header_keys:\n                    resource[header] = response.headers[header]\n\n                return resource\n\n            headers = {}\n\n            for header in header_keys:\n                headers[header] = response.headers[header]\n\n            return HttpResponse(response.content, status=response.status_code, headers=headers)\n\n        def _sync_get(self, url, params=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n\n            if self.sync is False:\n                params = kwargs.pop(\"params\", None)\n\n            headers = self._authenticate(\"get\", params=params, **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.get(url, params=params, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_options(self, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"options\", **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.options(url, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_head(self, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"head\", **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.head(url, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_post(self, url, data=None, json=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"post\", data=data, json=json, **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.post(url, data=data, json=json, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_webhook(self, url, data=None, json=None, **kwargs):\n            url = self.app.webhook_url\n            headers = self._authenticate(\"post\", data=data, json=json, **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.post(url, data=data, json=json, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_put(self, url, data=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"put\", data=data, **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.put(url, data=data, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_patch(self, url, data=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"patch\", data=data, **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.patch(url, data=data, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_delete(self, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"delete\", **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.delete(url, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n\n        def _sync_request(self, method, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(method, **kwargs)\n\n            def request() -&gt; requests.Response:\n                return requests.request(method, url, **kwargs, headers=headers)\n\n            if self.proxy:\n                return self._sync_proxy(request, kwargs.get(\"stream\", False))\n\n            res = request()\n\n            return res\n</code></pre>"},{"location":"extending-service/http-clients/#asyncservice-example","title":"<code>AsyncService</code> example","text":"<p>Implementing <code>aiohttp</code> library.</p> <pre><code>if LIBRARIES[\"aiohttp\"]:\n\n    class AsyncService:\n\n        async def __aenter__(self) -&gt; \"Service\":\n\n            self.sync = False\n\n            if isinstance(self.app_pk, self._get_app_cls()):\n                self.app = self.app_pk\n\n            else:\n                self.app = await sync_to_async(self._get_app)(self.app_pk)\n\n            self.session = aiohttp.ClientSession()\n\n            # this should be extended\n            await self.session.__aenter__()\n\n            return self\n\n        async def __aexit__(self, *args, **kwargs) -&gt; None:\n            for obj in self.to_close:\n                await obj.__aexit__(*args, **kwargs)\n\n            await self.session.__aexit__(*args, **kwargs)\n\n        # django does not support StreamingHttpResponse with aiohttp due to django would have to close the response\n        async def _async_proxy(self, response: Coroutine[Any, Any, ClientResponse]) -&gt; HttpResponse:\n            try:\n                r = await response\n\n            except Exception as e:\n                raise ValidationException(\"Unexpected error: \" + str(e), code=500, slug=\"unexpected-error\")\n\n            header_keys = [x for x in r.headers.keys() if x not in self.banned_keys]\n\n            headers = {}\n            for header in header_keys:\n                headers[str(header)] = r.headers[header]\n\n            return HttpResponse(await r.content.read(), status=r.status, headers=headers)\n\n        def _async_get(self, url, params=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"get\", params=params, **kwargs)\n\n            obj = self.session.get(url, params=params, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_options(self, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"options\", **kwargs)\n\n            obj = self.session.options(url, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_head(self, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"head\", **kwargs)\n\n            obj = self.session.head(url, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_post(self, url, data=None, json=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"post\", data=data, json=json, **kwargs)\n\n            obj = self.session.post(url, data=data, json=json, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_webhook(self, url, data=None, json=None, **kwargs):\n            url = self.app.webhook_url\n            headers = self._authenticate(\"post\", data=data, json=json, **kwargs)\n\n            obj = self.session.post(url, data=data, json=json, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_put(self, url, data=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"put\", data=data, **kwargs)\n\n            obj = self.session.put(url, data=data, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_patch(self, url, data=None, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"patch\", data=data, **kwargs)\n\n            obj = self.session.patch(url, data=data, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_delete(self, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(\"delete\", **kwargs)\n\n            obj = self.session.delete(url, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n\n        def _async_request(self, method, url, **kwargs):\n            url = self.app.app_url + self._fix_url(url)\n            headers = self._authenticate(method, **kwargs)\n\n            obj = self.session.request(method, url, **kwargs, headers=headers)\n            self.to_close.append(obj)\n\n            res = obj.__aenter__()\n\n            # wraps client response to be used within django views\n            if self.proxy:\n                return self._async_proxy(res)\n\n            return res\n</code></pre>"},{"location":"extending-service/rest-frameworks/","title":"Rest frameworks","text":"<p>You could implement a new REST framework extending <code>linked_services.core.service.Service</code>.</p>"},{"location":"extending-service/rest-frameworks/#methods","title":"Methods","text":"<ul> <li><code>__enter__</code>: called when it gets entered into an sync context.</li> <li><code>__aenter__</code>: called when it gets entered into an async context.</li> <li><code>_get_app_cls</code>: called when it needs to retrieve the application model class.</li> <li><code>_get_app</code>: called when it needs to retrieve an application instance.</li> <li><code>_get_signature</code>: called when it needs to retrieve a signature.</li> <li><code>_get_jwt</code>: called when it needs to retrieve a JWT.</li> </ul>"},{"location":"extending-service/rest-frameworks/#example","title":"Example","text":"<p>Implementing <code>djangorestframework</code>.</p> <pre><code>from typing import Any, Optional, Type\n\nfrom django.core.exceptions import SynchronousOnlyOperation\n\nfrom linked_services.core.exceptions import ValidationException\nfrom linked_services.core.service import AppNotFound\nfrom linked_services.core.service import Service as BaseService\nfrom linked_services.django.actions import get_app\nfrom linked_services.django.models import App\n\nhas_sync = hasattr(BaseService, \"__enter__\")\nhas_async = hasattr(BaseService, \"__aenter__\")\n\n\nclass Service(BaseService):\n    if has_sync:\n\n        def __enter__(self) -&gt; \"Service\":\n            try:\n                return super().__enter__()\n\n            except Exception:\n                if self.proxy:\n                    raise ValidationException(f\"App {self.app_pk} not found\", code=404, slug=\"app-not-found\")\n\n                raise AppNotFound(f\"App {self.app_pk} not found\")\n\n    if has_async:\n\n        async def __aenter__(self) -&gt; \"Service\":\n\n            try:\n                return await super().__aenter__()\n\n            except SynchronousOnlyOperation:\n                raise ValidationException(\n                    \"Async is not supported by the worker\",\n                    code=500,\n                    slug=\"no-async-support\",\n                )\n\n            except Exception:\n                if self.proxy:\n                    raise ValidationException(f\"App {self.app_pk} not found\", code=404, slug=\"app-not-found\")\n\n                raise AppNotFound(f\"App {self.app_pk} not found\")\n\n    def _get_app_cls(self) -&gt; Type[App]:\n        return App\n\n    def _get_app(self, pk: str | int) -&gt; App:\n        return get_app(pk)\n\n    def _get_signature(\n        self,\n        app: Any,\n        user_id: Optional[int] = None,\n        *,\n        method: str = \"get\",\n        params: Optional[dict] = None,\n        body: Optional[dict] = None,\n        headers: Optional[dict] = None,\n        reverse: bool = False,\n    ) -&gt; tuple[str, str]:\n        from .actions import get_signature\n\n        return get_signature(app, user_id, method=method, params=params, body=body, headers=headers, reverse=reverse)\n\n    def _get_jwt(self, app: Any, user_id: Optional[int] = None, reverse: bool = False) -&gt; str:\n        from .actions import get_jwt\n\n        return get_jwt(app, user_id, reverse=reverse)\n</code></pre>"},{"location":"fixtures/service/","title":"service","text":"<p>Set of utilities for formatting values.</p>"},{"location":"fixtures/service/#sign_jwt","title":"<code>sign_jwt</code>","text":"<p>Set Json Web Token in the request.</p>"},{"location":"fixtures/service/#arguments","title":"Arguments","text":"<ul> <li><code>client</code>: a <code>capy.Client</code> instance.</li> <li><code>app</code>: a <code>linked_services.django.models.App</code> instance.</li> <li><code>user_id</code>: an <code>user.id</code> as <code>int</code> or <code>None</code>.</li> <li><code>reverse</code>: if <code>True</code>, mark the tested app as the emitter of the request, otherwise mark it as the receiver.</li> </ul>"},{"location":"fixtures/service/#example","title":"Example","text":"<pre><code>import capyc.pytest as capy\nimport linked_services.pytest as linked_services\nfrom linked_services.django.models import App\n\n\ndef test_sign_request(client: capy.Client, service: linked_services.Service):\n    app = App.objects.first()\n    res = service.sign_jwt(client, app)\n    assert res is None\n\n\ndef test_sign_request_as_user(client: capy.Client, service: linked_services.Service):\n    app = App.objects.first()\n    res = service.sign_jwt(client, app, user_id=1)\n    assert res is None\n\n\ndef test_reverse_sign_request(client: capy.Client, service: linked_services.Service):\n    app = App.objects.first()\n    res = service.sign_jwt(client, app, reverse=True)\n    assert res is None\n\n\ndef test_reverse_sign_request_as_user(client: capy.Client, service: linked_services.Service):\n    app = App.objects.first()\n    res = service.sign_jwt(client, app, user_id=1, reverse=True)\n    assert res is None\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>You should install linked-services with a few optional dependencies running:</p> <pre><code>pip install linked-services[django,requests,aiohttp]\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional dependencies","text":""},{"location":"getting-started/installation/#django","title":"django","text":"<ul> <li>django</li> <li>djangorestframework</li> <li>celery-task-manager[django]</li> <li>adrf</li> </ul>"},{"location":"getting-started/installation/#requests","title":"requests","text":"<ul> <li>requests</li> <li>brotli</li> </ul>"},{"location":"getting-started/installation/#httpx","title":"httpx","text":"<ul> <li>httpx</li> <li>httpcore</li> <li>h11</li> <li>idna</li> <li>brotli</li> </ul>"},{"location":"getting-started/installation/#aiohttp","title":"aiohttp","text":"<ul> <li>aiohttp</li> <li>aiodns</li> <li>brotli</li> </ul>"},{"location":"getting-started/middlewares/","title":"Middlewares","text":""},{"location":"getting-started/middlewares/#linked_services_middleware","title":"<code>linked_services_middleware</code>","text":"<p>This middleware sets the <code>Service</code> header to the app name if it's not already set.</p> <pre><code>from linked_services.django.middlewares import linked_services_middleware\n\nMIDDLEWARE = [\n    ...\n    'linked_services.django.middlewares.linked_services_middleware',\n    ...\n]\n</code></pre>"},{"location":"getting-started/scopes/","title":"Scopes","text":"<p><code>scope</code> and <code>ascope</code> checks automatically the auth headers provided by its pairwise. It will check if the application that made the request has those required scopes to execute the request. All applications that does not requires an agreement will be treated as if these has all availabled scopes to execute the request.</p>"},{"location":"getting-started/scopes/#decorators","title":"Decorators","text":"<ul> <li><code>scope</code>: synchronous implementation that manages the authentication and it will checks the scopes if the current application requires an agreement.</li> <li><code>ascope</code>: asynchronous implementation that manages the authentication and it will checks the scopes if the current application requires an agreement.</li> </ul>"},{"location":"getting-started/scopes/#parameters","title":"Parameters","text":"<ul> <li>scopes: list of scopes.</li> <li>mode: use an alternative option to sign the request. Default is <code>JWT</code>.</li> </ul>"},{"location":"getting-started/scopes/#name-convention","title":"Name convention","text":"<p>I would recommend your that you would use the following naming convention, <code>action_name:data_name</code> like <code>read:repo</code> or <code>data_name</code> like <code>repo</code>.</p>"},{"location":"getting-started/scopes/#get-a-user","title":"Get a user","text":"<p><code>scope</code> and <code>ascope</code> inject a function called <code>get_user</code>, it's a synchronous implementation in <code>scope</code> and an asynchronous implementation in <code>ascope</code>. <code>get_user</code> returns a user object or none if does not exist an user in this app and in the related application.</p>"},{"location":"getting-started/scopes/#examples","title":"Examples","text":""},{"location":"getting-started/scopes/#sync","title":"Sync","text":"<p>You could want to use <code>scope</code> and <code>ascope</code> within a synchronous context if your framework does not support asynchronous operations.</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\n\nfrom .serializers import AppUserSerializer\n\nclass AppUserView(APIView):\n    permission_classes = [AllowAny]\n\n    @scope(['read:user'])\n    # action:data\n    def get(self, request, app: dict, token: dict, user_id=None):\n        # With the decorator I can access to the app and the token\n        extra = {}\n        if app.require_an_agreement:\n            extra['appuseragreement__app__id'] = app.id\n\n        if token.sub:\n            user = request.get_user()\n            extra['id'] = user.id\n\n        if user_id:\n            if 'id' in extra and extra['id'] != user_id:\n                raise ValidationException('This user does not have access to this resource',\n                                          code=403,\n                                          slug='user-with-no-access',\n                                          silent=True)\n\n            if 'id' not in extra:\n                extra['id'] = user_id\n\n            user = User.objects.filter(**extra).first()\n            if not user:\n                raise ValidationException('User not found',\n                                          code=404,\n                                          slug='user-not-found',\n                                          silent=True)\n\n            serializer = AppUserSerializer(user, many=False)\n            return Response(serializer.data)\n\n        # test this path\n        items = User.objects.filter(**extra)\n        serializer = AppUserSerializer(items, many=True)\n\n        return Response(serializer.data)\n</code></pre>"},{"location":"getting-started/scopes/#async","title":"Async","text":"<p>This is the most convenient option if you are using some ASGI server.</p> <pre><code>import asyncio\n\nfrom adrf.decorators import api_view\nfrom rest_framework.decorators import permission_classes\nfrom rest_framework.permissions import AllowAny\nfrom rest_framework.response import Response\nfrom linked_services.django.actions import aget_app\nfrom linked_services.django.models import FirstPartyWebhookLog\nfrom linked_services.rest_framework.decorators import ascope\n\n\n@api_view([\"POST\"])\n@permission_classes([AllowAny])\n@ascope([\"webhook\"], mode=\"jwt\")\nasync def app_webhook(request, app: dict, token: dict):\n\n    async def process_webhook(data):\n        nonlocal app, token\n\n        app = await aget_app(app.id)\n        external_id = data.get(\"id\", None)\n        kwargs = {\n            \"app\": app,\n            \"user_id\": token.sub,\n            \"external_id\": external_id,\n            \"type\": data.get(\"type\", \"unknown\"),\n        }\n        if external_id:\n            x, created = await FirstPartyWebhookLog.objects.aget_or_create(\n                **kwargs, defaults={\"data\": data.get(\"data\", None)}\n            )\n            if not created:\n                x.data = data.get(\"data\", None)\n                await x.asave()\n\n        else:\n            kwargs[\"data\"] = data.get(\"data\", None)\n            await FirstPartyWebhookLog.objects.acreate(**kwargs)\n\n    data = request.data if isinstance(request.data, list) else [request.data]\n\n    to_process = []\n\n    for x in data:\n        p = process_webhook(x)\n        to_process.append(p)\n\n    await asyncio.gather(*to_process)\n\n    return Response(None, status=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"getting-started/services/","title":"Services","text":"<p><code>Service</code> resolves automatically what is the credentials required by its pairwise. It could returns a HTTP response or a Rest response, depending it's used as proxy or it does not.</p>"},{"location":"getting-started/services/#examples","title":"Examples","text":""},{"location":"getting-started/services/#sync","title":"Sync","text":"<p>You could want to use <code>Service</code> within a synchronous context if your framework does not support asynchronous operations or if your are using Celery.</p>"},{"location":"getting-started/services/#proxy","title":"Proxy","text":"<pre><code>from rest_framework.views import APIView\nfrom linked_services.django.service import Service\n\n\nclass MeCodeRevisionView(APIView):\n\n    def get(self, request, task_id=None):\n        with Service('rigobot', request.user.id, proxy=True) as s:\n            return s.get('/v1/finetuning/me/coderevision', params=request.GET, stream=True)\n</code></pre>"},{"location":"getting-started/services/#client","title":"Client","text":"<pre><code>from linked_services.django.service import Service\n\n\ndef my_func(url, whatchers=None):\n    if whatchers is None:\n        whatchers = []\n\n    with Service('rigobot') as s:\n        if task.task_status == 'DONE':\n            response = s.post('/v1/finetuning/me/repository/',\n                                json={\n                                    'url': url,\n                                    'watchers': whatchers,\n                                })\n            data = response.json()\n            print(data)\n</code></pre>"},{"location":"getting-started/services/#async","title":"Async","text":"<p>This is the most convenient implementation of the service, because it blocks until the response is received. It's not compatible with celery yet.</p>"},{"location":"getting-started/services/#proxy_1","title":"Proxy","text":"<pre><code>from adrf.views import APIView\nfrom linked_services.django.service import Service\n\n\nclass MeCodeRevisionView(APIView):\n\n    def get(self, request, task_id=None):\n        async with Service('rigobot', request.user.id, proxy=True) as s:\n            return await s.get('/v1/finetuning/me/coderevision', params=request.GET)\n</code></pre>"},{"location":"getting-started/services/#client_1","title":"Client","text":"<pre><code>from linked_services.django.service import Service\n\n\nasync def my_func(url, whatchers=None):\n    if whatchers is None:\n        whatchers = []\n\n    async with Service('rigobot') as s:\n        if task.task_status == 'DONE':\n            response = await s.post('/v1/finetuning/me/repository/',\n                                json={\n                                    'url': url,\n                                    'watchers': whatchers,\n                                })\n            data = response.json()\n            print(data)\n</code></pre>"},{"location":"getting-started/services/#arguments","title":"Arguments","text":"<ul> <li><code>app_pk</code>: it could be the slug or the id of the application.</li> <li><code>user_pk</code>: it could be the username or the id of the user. Default is <code>None</code>.</li> <li><code>mode</code>: it can be one of the following, jwt or signature. Default is <code>jwt</code>.</li> <li><code>proxy</code>: if it's <code>True</code>, it returns a HTTP response in the chosen framework, like <code>djangorestframework</code>.</li> </ul>"},{"location":"getting-started/services/#returns","title":"Returns","text":"<ul> <li>If <code>Proxy is True</code>: returns a HTTP response of the chosen HTTP library.</li> <li>If <code>Proxy is not True</code>: returns a HTTP response of the chosen REST library.</li> </ul>"},{"location":"getting-started/services/#library-preferences","title":"Library preferences","text":""},{"location":"getting-started/services/#sync_1","title":"<code>sync</code>","text":"<ol> <li><code>httpx</code></li> <li><code>requests</code></li> </ol>"},{"location":"getting-started/services/#async_1","title":"<code>async</code>","text":"<ol> <li><code>aiohttp</code></li> <li><code>httpx</code></li> <li><code>requests</code></li> </ol>"},{"location":"getting-started/services/#which-http-libraries-are-supported-right-now","title":"Which HTTP libraries are supported right now","text":"<ul> <li><code>aiohttp</code></li> <li><code>requests</code></li> </ul>"},{"location":"getting-started/services/#which-rest-libraries-are-supported-right-now","title":"Which REST libraries are supported right now","text":"<ul> <li><code>djangorestframework</code></li> </ul>"},{"location":"getting-started/set-up/","title":"Set up","text":""},{"location":"getting-started/set-up/#add-an-application","title":"Add an application","text":"<p>Go to <code>/admin/linked_services/app/add/</code> and add the first application, it will generate automatically the keys, go to its pair and add the second application using the same key, key type and basic auth fields.</p>"},{"location":"getting-started/set-up/#which-algorithm-you-should-use","title":"Which algorithm you should use","text":"<p>The correct algorithm depends on your requirements, just avoid to use any signature algorithm, because it's significantly slower.</p>"},{"location":"getting-started/set-up/#add-first_party_webhooks-to-your-scheduler","title":"Add first_party_webhooks to your scheduler","text":"<p><code>python manage.py first_party_webhooks</code> routes all the incoming webhooks what was saved previously.</p>"},{"location":"getting-started/views/","title":"Views","text":"<p>Linked services implemented <code>authorize_view</code> and <code>app_webhook</code> endpoint handlers to share the implementation between all services.</p>"},{"location":"getting-started/views/#app_webhook","title":"<code>app_webhook</code>","text":"<p>It's a webhook endpoint that saves them to be processed by <code>first_party_webhooks</code> command.</p>"},{"location":"getting-started/views/#authorize_view","title":"<code>authorize_view</code>","text":"<p>It's a function that return an endpoint handler.</p>"},{"location":"getting-started/views/#arguments","title":"Arguments","text":"<ul> <li><code>login_url</code>: the login url. Default to <code>os.getenv(\"LOGIN_URL\")</code></li> <li><code>app_url</code>: the app url. Default to <code>os.getenv(\"APP_URL\")</code></li> <li><code>get_language</code>: a function that receives a request and returns the user language. Default to <code>lambda request: 'en'</code></li> </ul>"},{"location":"getting-started/views/#example","title":"Example","text":"<pre><code>from django.urls import path\nfrom linked_services.rest_framework.views import app_webhook, authorize_view\n\nfrom breathecode.authenticate.actions import get_user_language\n\n\napp_name = 'authenticate'\nurlpatterns = [\n    # authorize\n    path('authorize/&lt;str:app_slug&gt;',\n         authorize_view(login_url='/v1/auth/view/login', get_language=get_user_language),\n         name='authorize_slug'),\n\n    path('app/webhook', app_webhook, name='app_webhook'),\n]\n</code></pre>"}]}